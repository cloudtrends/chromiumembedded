diff --git compositing_iosurface_layer_mac.mm compositing_iosurface_layer_mac.mm
index 0a06d78..72a6d78 100644
--- compositing_iosurface_layer_mac.mm
+++ compositing_iosurface_layer_mac.mm
@@ -89,7 +89,7 @@
 
   if (!context_.get() || !renderWidgetHostView_ ||
       !renderWidgetHostView_->compositing_iosurface_) {
-    glClearColor(1, 1, 1, 1);
+    glClearColor(0, 0, 0, 0);
     glClear(GL_COLOR_BUFFER_BIT);
     return;
   }
diff --git compositing_iosurface_mac.mm compositing_iosurface_mac.mm
index e948863..0031eaa 100644
--- compositing_iosurface_mac.mm
+++ compositing_iosurface_mac.mm
@@ -427,7 +427,7 @@ bool CompositingIOSurfaceMac::DrawIOSurface(
     glUseProgram(0); CHECK_AND_SAVE_GL_ERROR();
   } else {
     // Should match the clear color of RenderWidgetHostViewMac.
-    glClearColor(1.0f, 1.0f, 1.0f, 1.0f);
+    glClearColor(0, 0, 0, 0);
     glClear(GL_COLOR_BUFFER_BIT);
   }
 
diff --git compositing_iosurface_shader_programs_mac.cc compositing_iosurface_shader_programs_mac.cc
index 87f0f34..0fdc564 100644
--- compositing_iosurface_shader_programs_mac.cc
+++ compositing_iosurface_shader_programs_mac.cc
@@ -11,6 +11,8 @@
 #include "base/debug/trace_event.h"
 #include "base/logging.h"
 #include "base/memory/scoped_ptr.h"
+#include "base/strings/stringprintf.h"
+#include "base/strings/string_number_conversions.h"
 #include "base/values.h"
 #include "content/browser/gpu/gpu_data_manager_impl.h"
 #include "gpu/config/gpu_driver_bug_workaround_type.h"
@@ -51,6 +53,7 @@ const char kfsBlit[] = GLSL_PROGRAM_AS_STRING(
     }
 );
 
+float bgcolor[] = {1.0f, 1.0f, 1.0f};
 
 // Only calculates position.
 const char kvsSolidWhite[] = GLSL_PROGRAM_AS_STRING(
@@ -238,6 +241,18 @@ GLuint CompileShaderGLSL(ShaderProgram shader_program, GLenum shader_type,
   const GLuint shader = glCreateShader(shader_type);
   DCHECK_NE(shader, 0u);
 
+  // Support customization of the background color.
+  std::string bg_shader;
+  if (shader_program == SHADER_PROGRAM_SOLID_WHITE &&
+      shader_type == GL_FRAGMENT_SHADER) {
+    bg_shader = base::StringPrintf(
+        "void main() { gl_FragColor = vec4(%s, %s, %s, 1.0); }",
+        base::DoubleToString(bgcolor[0]).c_str(),
+        base::DoubleToString(bgcolor[1]).c_str(),
+        base::DoubleToString(bgcolor[2]).c_str());
+    kFragmentShaderSourceCodeMap[shader_program] = bg_shader.c_str();
+  }
+
   // Select and compile the shader program source code.
   if (shader_type == GL_VERTEX_SHADER) {
     const GLchar* source_snippets[] = {
@@ -414,6 +429,14 @@ void CompositingIOSurfaceShaderPrograms::SetOutputFormatForTesting(
   Reset();
 }
 
+// static
+void CompositingIOSurfaceShaderPrograms::SetBackgroundColor(
+    float r, float g, float b) {
+  bgcolor[0] = r;
+  bgcolor[1] = g;
+  bgcolor[2] = b;
+}
+
 GLuint CompositingIOSurfaceShaderPrograms::GetShaderProgram(int which) {
   if (shader_programs_[which] == 0u) {
     shader_programs_[which] =
diff --git compositing_iosurface_shader_programs_mac.h compositing_iosurface_shader_programs_mac.h
index de1987f..d36b988 100644
--- compositing_iosurface_shader_programs_mac.h
+++ compositing_iosurface_shader_programs_mac.h
@@ -48,6 +48,8 @@ class CompositingIOSurfaceShaderPrograms {
     return rgb_to_yv12_output_format_;
   }
 
+  static void SetBackgroundColor(float r, float g, float b);
+
  protected:
   FRIEND_TEST_ALL_PREFIXES(CompositingIOSurfaceTransformerTest,
                            TransformsRGBToYV12);
diff --git render_widget_host_view_aura.cc render_widget_host_view_aura.cc
index 7f98b5d..5796361 100644
--- render_widget_host_view_aura.cc
+++ render_widget_host_view_aura.cc
@@ -2556,8 +2556,14 @@ void RenderWidgetHostViewAura::OnPaint(gfx::Canvas* canvas) {
     // For non-opaque windows, we don't draw anything, since we depend on the
     // canvas coming from the compositor to already be initialized as
     // transparent.
-    if (window_->layer()->fills_bounds_opaquely())
-      canvas->DrawColor(SK_ColorWHITE);
+    if (window_->layer()->fills_bounds_opaquely()) {
+      if (host_->IsRenderView()) {
+        canvas->DrawColor(GetContentClient()->browser()->GetBaseBackgroundColor(
+            RenderViewHost::From(host_)));
+      } else {
+        canvas->DrawColor(SK_ColorWHITE);
+      }
+    }
   }
 }
 
diff --git render_widget_host_view_mac.mm render_widget_host_view_mac.mm
index 23a6e3c..f17238f 100644
--- render_widget_host_view_mac.mm
+++ render_widget_host_view_mac.mm
@@ -494,7 +494,7 @@ void RenderWidgetHostViewMac::EnableCoreAnimation() {
   software_layer_.reset([[CALayer alloc] init]);
   if (!software_layer_)
     LOG(ERROR) << "Failed to create CALayer for software rendering";
-  [software_layer_ setBackgroundColor:CGColorGetConstantColor(kCGColorWhite)];
+  [software_layer_ setBackgroundColor:CGColorGetConstantColor(kCGColorClear)];
   [software_layer_ setDelegate:cocoa_view_];
   [software_layer_ setContentsGravity:kCAGravityTopLeft];
   [software_layer_ setFrame:NSRectToCGRect([cocoa_view_ bounds])];
@@ -2868,7 +2868,7 @@ void RenderWidgetHostViewMac::FrameSwapped() {
 
     NSRect r = [self flipRectToNSRect:gfx::Rect(x, y, width, height)];
     CGContextSetFillColorWithColor(context,
-                                   CGColorGetConstantColor(kCGColorWhite));
+                                   CGColorGetConstantColor(kCGColorClear));
     CGContextFillRect(context, NSRectToCGRect(r));
   }
   if (damagedRect.bottom() > rect.bottom()) {
@@ -2890,7 +2890,7 @@ void RenderWidgetHostViewMac::FrameSwapped() {
 
     NSRect r = [self flipRectToNSRect:gfx::Rect(x, y, width, height)];
     CGContextSetFillColorWithColor(context,
-                                   CGColorGetConstantColor(kCGColorWhite));
+                                   CGColorGetConstantColor(kCGColorClear));
     CGContextFillRect(context, NSRectToCGRect(r));
   }
 }
@@ -3051,7 +3051,7 @@ void RenderWidgetHostViewMac::FrameSwapped() {
     }
   } else {
     CGContextSetFillColorWithColor(context,
-                                   CGColorGetConstantColor(kCGColorWhite));
+                                   CGColorGetConstantColor(kCGColorClear));
     CGContextFillRect(context, dirtyRect);
     if (renderWidgetHostView_->whiteout_start_time_.is_null())
       renderWidgetHostView_->whiteout_start_time_ = base::TimeTicks::Now();
@@ -4058,7 +4058,7 @@ extern NSString *NSTextInputReplacementRangeAttributeName;
   if (!renderWidgetHostView_->render_widget_host_ ||
       renderWidgetHostView_->render_widget_host_->is_hidden()) {
     CGContextSetFillColorWithColor(context,
-                                   CGColorGetConstantColor(kCGColorWhite));
+                                   CGColorGetConstantColor(kCGColorClear));
     CGContextFillRect(context, clipRect);
     return;
   }
